import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Exam } from './exam.entity';
import { DataSource, FindManyOptions, FindOneOptions, FindOptionsWhere, In, Like, QueryRunner, Repository, getConnection } from 'typeorm';
import * as ExcelJS from "exceljs"
import { CategoriesElementAutoGenerate, CreateExamDto, ExamAutoGenerateDto, ExamEndDto, FilterDto, UpdateExamDto } from './dto';
import { PayloadTokenInterface, ResponseServiceInterface } from 'src/common/interface';
import { Helper } from 'src/common/helper';
import { SlugService } from 'src/slug/slug.service';
import { MessageError } from 'src/common/enum/error.enum';
import { SlugType } from 'src/common/enum/slug.enum';
import { CategoryService } from 'src/category/category.service';
import { BaseListFilterDto } from 'src/common/base/base.list';
import { UploadExamDto } from './dto/upload-exam.dto';
import { Question } from 'src/question/question.entity';
import { Answer } from 'src/answer/answer.entity';
import { ExamQuestion } from 'src/exam-question/exam-question.entity';
import { Slug } from 'src/slug/slug.entity';
import { ExamType } from 'src/common/enum/exam.enum';
import * as fs from "fs"
import { UserService } from 'src/user/user.service';
import { ExamQuestionService } from 'src/exam-question/exam-question.service';
import { v4 as uuidv4 } from 'uuid';
import { CATEGORY_DEFAULT_GENERATE_TEXT } from 'src/common/constants';
import { ExamHistory } from 'src/exam-history/exam-history.entity';
import { HistoryAnswer } from 'src/history-answer/history-answer.entity';
import { User } from 'src/user/user.entity';

@Injectable()
export class ExamService {
    constructor(
        @InjectRepository(Exam) private readonly repository: Repository<Exam>,
        @InjectRepository(Question) private readonly questionRepository: Repository<Question>,
        @InjectRepository(Answer) private readonly answerRepository: Repository<Answer>,
        @InjectRepository(ExamQuestion) private readonly examQuestionRepository: Repository<ExamQuestion>,
        @InjectRepository(ExamHistory) private readonly examHistoryRepository: Repository<ExamHistory>,
        @InjectRepository(HistoryAnswer) private readonly historyAnswerRepository: Repository<HistoryAnswer>,
        private readonly slugService: SlugService,
        private readonly categoryService: CategoryService,
        private readonly userService: UserService,
        private readonly examQuestionService: ExamQuestionService,
        private dataSource: DataSource
    ) { }

    async findOne(condition: FindOneOptions<Exam>): Promise<Exam> {
        return this.repository.findOne(condition)
    }

    async updateOne(condition: FindOptionsWhere<Exam>, data: Partial<Exam>, options?: Omit<FindOneOptions<Exam>, 'where'>): Promise<Exam> {
        await this.repository.update(condition, data)
        return this.repository.findOne({ where: condition, ...options })
    }

    async save(data: any): Promise<Exam> {
        const entity = Object.assign(new Exam(), data);
        return this.repository.save(entity);
    }

    async find({ where = {}, skip = 0, take = 10, order = { created_at: "DESC" }, ...args }: FindManyOptions<Exam>): Promise<Exam[]> {
        return this.repository.find({
            where,
            order,
            skip,
            take,
            ...args
        })
    }

    async findAndCount({ where = {}, skip = 0, take = 10, order = { created_at: "DESC" }, ...args }: FindManyOptions<Exam>): Promise<[Exam[], number]> {
        return this.repository.findAndCount({
            where,
            order,
            skip,
            take,
            ...args
        })
    }

    async count(condition: FindManyOptions<Exam>): Promise<number> {
        return this.repository.count(condition)
    }

    async autoGenerateExam(user: PayloadTokenInterface, body: ExamAutoGenerateDto): Promise<ResponseServiceInterface<any>> {
        const queryRunner = this.dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();

        try {
            let checkUser = await this.userService.count({ where: { id: user.id } })
            if (!checkUser) {
                return { error: MessageError.ERROR_NOT_FOUND, data: null }
            }
            let { categories, lang_type, total_questions } = body
            let totalQuestions = total_questions ? total_questions : 60
            let sumPercent: number = 0
            let totalQuestionFromPercent: number = 0
            let newCategories: (CategoriesElementAutoGenerate & { take: number })[] = categories.map((category: CategoriesElementAutoGenerate) => {
                let take = Math.floor(60 * (category.percent / 100))
                sumPercent += category.percent
                totalQuestionFromPercent += take
                return {
                    ...category,
                    take
                }
            })
            let missingQuestions: number = totalQuestions - totalQuestionFromPercent
            let countFillQuestionForCategory: number = Math.floor(missingQuestions / newCategories.length)
            let indexFillQuestion: number = 0
            let count = !countFillQuestionForCategory ? 1 : countFillQuestionForCategory
            while (missingQuestions > 0) {
                newCategories[indexFillQuestion].take += count
                missingQuestions -= count
                indexFillQuestion = indexFillQuestion == (newCategories.length - 1) ? 0 : indexFillQuestion + 1
            }

            let generateText = CATEGORY_DEFAULT_GENERATE_TEXT + '-' + uuidv4()
            let slugDB = await queryRunner.manager.save(Slug, {
                slug: generateText,
                type: SlugType.exam,
            })
            let category = await this.categoryService.findOne({ where: { title: CATEGORY_DEFAULT_GENERATE_TEXT } })
            let newExam: Partial<Exam> = {
                title: generateText,
                category,
                slug: slugDB,
                total_generate_question: totalQuestions,
                lang_type,
                user_id: user.id,
                type: ExamType.auto,
                log_auto_category_id: JSON.stringify(newCategories)
            }
            let examDB = await queryRunner.manager.save(Exam, newExam)
            let randomQuestions: any = []
            await Promise.all(
                newCategories.map(async (category) => {
                    let getExams = await this.find({ where: { category_id: category.category_id }, select: ["id"] })
                    let examIds = getExams.map((exam: any) => exam.id)
                    let getRandomQuestion = await this.examQuestionRepository
                        .createQueryBuilder("e")
                        .where("e.exam_id IN (:...exam_ids)", { exam_ids: examIds })
                        .orderBy('RAND()')
                        .take(category.take)
                        .getMany()
                    randomQuestions.push(...getRandomQuestion)
                })
            )
            let dataInsert: any = []
            randomQuestions = randomQuestions.map((q: any) => {
                dataInsert.push({ question_id: q.question_id, exam_id: examDB.id })
                return q.question
            })
            await queryRunner.manager.insert(ExamQuestion, dataInsert)
            await queryRunner.commitTransaction()
            return {
                error: null, data: { exam: examDB, message: "Done!" }
            }
        } catch (error) {
            await queryRunner.rollbackTransaction();
            return { error: error, data: null }
        } finally {
            await queryRunner.release()
        }

    }

    async handleUploadExcel(file: Express.Multer.File, body: UploadExamDto, user: PayloadTokenInterface): Promise<ResponseServiceInterface<any>> {
        const queryRunner = this.dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            if (!file.path) {
                throw new Error("Upload failed");
            }
            let { category_id, lang_type, exam_id } = body
            let category = await this.categoryService.findOne({ where: { id: category_id } })
            if (!category) {
                return { error: MessageError.ERROR_NOT_FOUND + 'category', data: null }
            }

            const workbook = new ExcelJS.Workbook();
            await workbook.xlsx.readFile(file.path);
            let promises = []

            if (exam_id != undefined) {
                let exam = await this.findOne({ where: { id: exam_id } })
                if (!exam) {
                    return { error: MessageError.ERROR_NOT_FOUND + 'exam', data: null }
                }
                let worksheet = workbook.getWorksheet(1);
                worksheet.eachRow({ includeEmpty: false }, async (row, rowNumber) => {
                    if (rowNumber == 1) return
                    promises.push(this.handleInsertQuestionAndAnswer(queryRunner, exam, row, rowNumber))
                });
            } else {
                let sheets = Array.from({ length: workbook.worksheets.length }, (_: any, i: number) => workbook.getWorksheet(i + 1))
                await Promise.all(
                    sheets.map(async (worksheet: ExcelJS.Worksheet, index: number) => {
                        let slugText = Helper.removeAccents(worksheet.name, true)
                        let checkSlug = await this.slugService.count({ where: { slug: slugText } })
                        let slugDB = await queryRunner.manager.save(Slug, {
                            slug: checkSlug != 0 ? slugText + "d" : slugText,
                            type: SlugType.exam,
                        })
                        let newExam: Partial<Exam> = {
                            title: worksheet.name,
                            category,
                            lang_type,
                            slug: slugDB,
                            type: ExamType.user,
                            user_id: user.id
                        }
                        let examDB = await queryRunner.manager.save(Exam, newExam)
                        worksheet.eachRow({ includeEmpty: false }, async (row, rowNumber) => {
                            if (rowNumber == 1) return
                            promises.push(this.handleInsertQuestionAndAnswer(queryRunner, examDB, row, rowNumber))
                        });
                    })
                )

            }
            await Promise.all(promises)
            await queryRunner.commitTransaction();
            return { error: null, data: {} }
        } catch (error) {
            await queryRunner.rollbackTransaction();
            return { error: error, data: null }
        } finally {
            fs.unlinkSync(file.path)
            await queryRunner.release()
        }

    }

    async handleInsertQuestionAndAnswer(queryRunner: QueryRunner, exam: Exam, rows: ExcelJS.Row, rowNumber?: number): Promise<void> {
        if (rowNumber == 1) return
        let [_, questionIsr, aIsr, bIsr, cIsr, dIsr, answerIsr, recommendIsr]: any = rows.values
        let answersObj = {
            'a': aIsr,
            'b': bIsr,
            'c': cIsr,
            'd': dIsr,
        }
        let correctAnswer = answerIsr.trim().toLowerCase()
        let questionDb = await queryRunner.manager.save(Question, {
            title: questionIsr,
            recommend: recommendIsr
        })
        let answersDb = await Promise.all(
            Object.keys(answersObj).map(async (key) => {
                return queryRunner.manager.save(Answer, {
                    title: answersObj[key],
                    correct: answersObj[correctAnswer] && key == correctAnswer ? true : false,
                    question: questionDb
                })
            })
        )
        let checkAllTrue = answersDb.every((anw: Answer) => anw.correct)
        let checkAllFalse = answersDb.every((anw: Answer) => !anw.correct)
        if (checkAllTrue || checkAllFalse) {
            throw new Error(`Can detect correct answer for question: ` + questionDb.title)
        }
        await queryRunner.manager.save(ExamQuestion, {
            exam,
            question: questionDb
        })
    }

    async createExam(data: CreateExamDto, user: PayloadTokenInterface): Promise<ResponseServiceInterface<Partial<Exam>>> {
        let { title, category_id, time_end, time_start, total_generate_question, lang_type } = data
        let category = await this.categoryService.findOne({ where: { id: category_id } })
        if (!category) {
            return { error: MessageError.ERROR_NOT_FOUND + 'category', data: null }
        }
        let withTime = true
        let slug = Helper.removeAccents(title, withTime)
        let checkSlug = await this.slugService.count({ where: { slug } })
        if (!!checkSlug) {
            return { error: MessageError.ERROR_EXISTS, data: null }
        }
        let newSlug = await this.slugService.save({ slug, type: SlugType.exam })
        let dataCreate: Partial<Exam> = {
            title,
            category,
            slug: newSlug,
            total_generate_question,
            lang_type,
            user_id: user.id
        }
        if (time_end && time_start) {
            dataCreate.time_start = time_start
            dataCreate.time_end = time_end
        }
        let newExam = await this.save(dataCreate)
        return {
            error: null,
            data: newExam
        }
    }

    async updateExam(id: number, data: UpdateExamDto): Promise<ResponseServiceInterface<Partial<Exam>>> {
        let { title, category_id, time_end, time_start, total_generate_question, lang_type } = data
        let exam = await this.findOne({ where: { id } })
        let examUpdate: Partial<Exam> = {}
        if (!exam) {
            return { error: MessageError.ERROR_NOT_FOUND, data: null }
        }
        if (![undefined, exam.category_id].includes(category_id)) {
            let category = await this.categoryService.findOne({ where: { id: category_id } })
            if (!category) {
                return { error: MessageError.ERROR_NOT_FOUND + 'category', data: null }
            }
            examUpdate.category = category
        }
        if (title) {
            let slugUpdate = Helper.removeAccents(title, false)
            let slugDB = Helper.removeAccents(exam.title, false)
            if (slugUpdate != slugDB) {
                slugUpdate += "-" + Date.now()
                let checkSlug = await this.slugService.count({ where: { slug: slugUpdate } })
                console.log(checkSlug)
                if (!!checkSlug) {
                    return { error: MessageError.ERROR_EXISTS, data: null }
                }
                examUpdate.slug = await this.slugService.updateOne({ id: exam.slug_id }, { slug: slugUpdate })
                examUpdate.title = title
            }
        }
        if (time_end && time_start) {
            examUpdate.time_start = time_start
            examUpdate.time_end = time_end
        }
        examUpdate.lang_type = lang_type
        examUpdate.total_generate_question = total_generate_question
        let update = await this.updateOne({ id: exam.id }, examUpdate, { relations: ["slug", "category"] })
        return {
            error: null,
            data: update
        }
    }

    async getListExam(filter: BaseListFilterDto<any, any>): Promise<ResponseServiceInterface<any>> {
        let { limit = 10, page = 1 } = filter
        let condition = this.handleFilter(filter, page, limit)
        let [list, total] = await this.findAndCount(condition)
        return {
            error: null,
            data: {
                list,
                total,
                page,
                limit,
            }
        }
    }

    handleFilter(payload: BaseListFilterDto<FilterDto, any>, page: number, limit: number): FindManyOptions {
        let condition: FindManyOptions<Exam> = {
            select: {
                slug: {
                    id: true,
                    slug: true,
                    type: true
                },
                category: {
                    id: true,
                    title: true,
                    type: true
                }
            },
            order: payload.sort,
            take: limit,
            skip: (page - 1) * limit,
            relations: {
                slug: true,
                category: true
            }
        }
        let where: FindOptionsWhere<Partial<Exam>> = {};
        if (payload.search) {
            let search = Helper.removeAccents(payload.search, false)
            where.slug = {
                slug: Like(`%${search}%`)
            }
        }
        if (payload?.filter?.type) {
            where.type = payload.filter.type as any
        }
        if (payload?.filter?.category_id) {
            where.category_id = payload.filter?.category_id
        }
        if (payload?.filter?.lang_type) {
            where.lang_type = payload.filter.lang_type as any
        }
        if (Object.keys(where).length > 0) {
            condition.where = where
        }
        return condition
    }

    async startExam(slug: string, user: PayloadTokenInterface, query: any): Promise<any> {
        let { page = 1, limit = 60 } = query
        let exam = await this.findOne({ where: { slug: { slug } } })
        if (!exam || exam?.hidden) {
            return { error: MessageError.ERROR_NOT_FOUND, data: null }
        }
        let timeCurrent = new Date()
        let timeCurrentMili = timeCurrent.getTime()
        if (exam.time_end && exam.time_end < timeCurrent) {
            return { error: MessageError.ERROR_EXPIRES_EXAM, data: null }
        }
        if (exam.time_start && exam.time_start > timeCurrent) {
            return { error: MessageError.ERROR_EXPIRES_EXAM, data: null }
        }

        let historyBuildQuery = this.examHistoryRepository
            .createQueryBuilder("ex")
            .innerJoinAndSelect("ex.history_answers", "ha")
            .where("ex.exam_id = :exam_id", { exam_id: exam.id })
            .andWhere("ex.user_id = :user_id", { user_id: user.id })
            .orderBy("ex.created_at", "DESC")

        let buildQuery = this.examQuestionRepository
            .createQueryBuilder("eq")
            .leftJoin("eq.question", "q")
            .addSelect(["q.id", "q.title", "q.type"])
            .leftJoin("q.answers", "a")
            .addSelect(["a.id", "a.title", "a.default_order"])
            .where("eq.exam_id = :exam_id", { exam_id: exam.id })

        let latestHistory = await historyBuildQuery.getOne()
        // Điều kiện chưa có lịch sử or lịch sử làm bài kết thúc thi thì tạo mới lịch sử 
        // TH1: Nếu thời gian làm bài được set. Tính thời gian làm bài mới nhất + số phút làm so với time hiện tại quá hay chưa? 
        let timeCondition = (exam.time_work_minutes && (latestHistory?.start_time.getTime() + exam.time_work_minutes * 60 * 1000 < timeCurrentMili));
        let condition = !latestHistory
            || (latestHistory && latestHistory.end_time)
            || timeCondition;

        condition && (buildQuery = buildQuery.orderBy('RAND()'))
        let questionsRandom = await buildQuery.getMany()

        let countWork = await this.examHistoryRepository.count({ where: { exam_id: exam.id, user_id: user.id } })
        console.log(countWork)
        if (countWork >= exam.total_work && (timeCondition || !exam.time_work_minutes)) {
            return { error: MessageError.ERROR_EXPIRES_EXAM, data: null }
        }

        if (condition) {
            console.log("create new history")
            let newHistory: Partial<ExamHistory> = {
                start_time: timeCurrent,
                user: user as User,
                exam: exam
            }
            let history = await this.examHistoryRepository.save(newHistory)
            let historyAnswers = questionsRandom.map(record => {
                return {
                    question: record.question,
                    exam_history: history
                }
            })
            await this.historyAnswerRepository.insert(historyAnswers)
            latestHistory = await historyBuildQuery.getOne()
        }

        let logQuestionIds = latestHistory.history_answers.sort((a, b) => a.id - b.id).map((i) => {
            return {
                id: i.question_id,
                answer_id: i.answer_id
            }
        })
        let newQuestionsRandom: any[] = []
        newQuestionsRandom = logQuestionIds.map((q) => {
            let find = questionsRandom.find((question) => question.question_id === q.id)
            find.question.answers.sort((a, b) => a.default_order - b.default_order)
            return { ...find.question, answer_id: q.answer_id }
        })

        return {
            error: null, data: {
                exam,
                list: newQuestionsRandom.splice((page - 1) * limit, limit),
                // latestHistory
            }
        }
    }

    async endExam(slug: string, user: PayloadTokenInterface, body: ExamEndDto): Promise<any> {
        let { form } = body
        let exam = await this.findOne({ where: { slug: { slug } } })
        if (!exam) {
            return { error: MessageError.ERROR_NOT_FOUND, data: null }
        }
        let timeCurrent = new Date()
        let timeCurrentMili = timeCurrent.getTime()
        if (exam.time_end && exam.time_end < timeCurrent) {
            return { error: MessageError.ERROR_EXPIRES_EXAM, data: null }
        }
        if (exam.time_start && exam.time_start > timeCurrent) {
            return { error: MessageError.ERROR_EXPIRES_EXAM, data: null }
        }
        
        let questionsExam = await this.examQuestionRepository.find({
            where: { exam_id: exam.id },
            relations: {
                question: { answers: true }
            }
        })

        let historyExam = await this.examHistoryRepository.findOne({
            where: { exam_id: exam.id, user_id: user.id },
            order: { created_at: "DESC" }
        })

        if (historyExam.end_time) {
            return { error: MessageError.ERROR_EXPIRES_EXAM, data: null }
        }

        let totalQuestionCorrect = 0
        let questionScore = exam.score / questionsExam.length
        await Promise.all(
            questionsExam.map(async (row) => {
                let submitElement = form.find(q => q.question_id == row.question_id);
                let correctRow = row.question.answers.find(a => a.id == submitElement?.answer_id)
                if (submitElement && correctRow?.correct) {
                    totalQuestionCorrect++
                    await this.historyAnswerRepository.update({ 
                        question_id: row.question_id, 
                        exam_history_id: historyExam.id 
                    }, {
                        score: questionScore,
                        correct: true,
                        answer_id: String(submitElement.answer_id)
                    })
                }
            })
        )  
        
        historyExam.end_time = new Date()
        historyExam.score = questionScore * totalQuestionCorrect
        historyExam.total_correct_answer = totalQuestionCorrect
        await this.examHistoryRepository.save(historyExam)
        return { data: { historyExam } }
    }

    async updateLog(): Promise<any> {

    }

}   
