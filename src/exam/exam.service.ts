import { Inject, Injectable, forwardRef } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Exam } from './exam.entity';
import { DataSource, FindManyOptions, FindOneOptions, FindOptionsWhere, In, Like, QueryRunner, Repository, SelectQueryBuilder, getConnection } from 'typeorm';
import * as ExcelJS from "exceljs"
import { CategoriesElementAutoGenerate, CreateExamDto, ExamAutoGenerateDto, ExamEndDto, FilterDto, UpdateExamDto, UpdateLogExamDto } from './dto';
import { PayloadTokenInterface, ResponseServiceInterface } from 'src/common/interface';
import { Helper } from 'src/common/helper';
import { MessageError } from 'src/common/enum/error.enum';
import { SlugType } from 'src/common/enum/slug.enum';
import { BaseListFilterDto } from 'src/common/base/base.list';
import { UploadExamDto } from './dto/upload-exam.dto';
import { Question } from 'src/question/question.entity';
import { Answer } from 'src/answer/answer.entity';
import { ExamQuestion } from 'src/exam-question/exam-question.entity';
import { Slug } from 'src/slug/slug.entity';
import { ExamType } from 'src/common/enum/exam.enum';
import * as fs from "fs"
import { v4 as uuidv4 } from 'uuid';
import { CATEGORY_DEFAULT_GENERATE_TEXT } from 'src/common/constants';
import { ExamHistory } from 'src/exam-history/exam-history.entity';
import { HistoryAnswer } from 'src/history-answer/history-answer.entity';
import { User } from 'src/user/user.entity';
import { Category } from 'src/category/category.entity';
import { CategoryExam } from 'src/category-exam/category-exam.entity';
import { Media } from 'src/media/media.entity';
import { MediaType } from 'src/common/enum/media.enum';

@Injectable()
export class ExamService {
    constructor(
        @InjectRepository(Exam)
        private readonly repository: Repository<Exam>,
        @InjectRepository(ExamQuestion)
        private readonly examQuestionRepository: Repository<ExamQuestion>,
        @InjectRepository(ExamHistory)
        private readonly examHistoryRepository: Repository<ExamHistory>,
        @InjectRepository(HistoryAnswer)
        private readonly historyAnswerRepository: Repository<HistoryAnswer>,
        @InjectRepository(Category)
        private readonly categoryRepository: Repository<Category>,
        @InjectRepository(Slug)
        private readonly slugRepository: Repository<Slug>,
        @InjectRepository(User)
        private readonly userRepository: Repository<User>,
        @InjectRepository(CategoryExam)
        private readonly categoryExamRepository: Repository<CategoryExam>,
        @InjectRepository(Media)
        private readonly mediaRepository: Repository<Media>,
        private dataSource: DataSource
    ) { }

    async findOne(condition: FindOneOptions<Exam>): Promise<Exam> {
        return this.repository.findOne(condition)
    }

    async updateOne(condition: FindOptionsWhere<Exam>, data: Partial<Exam>, options?: Omit<FindOneOptions<Exam>, 'where'>): Promise<Exam> {
        await this.repository.update(condition, data)
        return this.repository.findOne({ where: condition, ...options })
    }

    async save(data: any): Promise<Exam> {
        const entity = Object.assign(new Exam(), data);
        return this.repository.save(entity);
    }

    async find({ where = {}, skip = 0, take = 10, order = { created_at: "DESC" }, ...args }: FindManyOptions<Exam>): Promise<Exam[]> {
        return this.repository.find({
            where,
            order,
            skip,
            take,
            ...args
        })
    }

    async findAndCount({ where = {}, skip = 0, take = 10, order = { created_at: "DESC" }, ...args }: FindManyOptions<Exam>): Promise<[Exam[], number]> {
        return this.repository.findAndCount({
            where,
            order,
            skip,
            take,
            ...args
        })
    }

    async count(condition: FindManyOptions<Exam>): Promise<number> {
        return this.repository.count(condition)
    }

    async autoGenerateExam(user: PayloadTokenInterface, body: ExamAutoGenerateDto): Promise<ResponseServiceInterface<any>> {
        const queryRunner = this.dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();

        try {
            let checkUser = await this.userRepository.count({ where: { id: user.id } })
            if (!checkUser) {
                return { error: MessageError.ERROR_NOT_FOUND, data: null }
            }
            let { categories, lang_type, total_question } = body
            let totalQuestions = total_question ? total_question : 60
            let sumPercent: number = 0
            let totalQuestionFromPercent: number = 0
            let newCategories: (CategoriesElementAutoGenerate & { take: number })[] = categories.map((category: CategoriesElementAutoGenerate) => {
                let take = Math.floor(60 * (category.percent / 100))
                sumPercent += category.percent
                totalQuestionFromPercent += take
                return {
                    ...category,
                    take
                }
            })
            let missingQuestions: number = totalQuestions - totalQuestionFromPercent
            let countFillQuestionForCategory: number = Math.floor(missingQuestions / newCategories.length)
            let indexFillQuestion: number = 0
            let count = !countFillQuestionForCategory ? 1 : countFillQuestionForCategory
            while (missingQuestions > 0) {
                newCategories[indexFillQuestion].take += count
                missingQuestions -= count
                indexFillQuestion = indexFillQuestion == (newCategories.length - 1) ? 0 : indexFillQuestion + 1
            }

            let generateText = 'exam-' + uuidv4()
            let slugDB = await queryRunner.manager.save(Slug, {
                slug: generateText,
                type: SlugType.exam,
            })
            // let category = await this.categoryRepository.findOne({ where: { title: CATEGORY_DEFAULT_GENERATE_TEXT } })
            let newExam: Partial<Exam> = {
                title: generateText,
                // category,
                slug: slugDB,
                // total_generate_question: totalQuestions,
                lang_type,
                user_id: user.id,
                type: ExamType.auto
            }
            let examDB = await queryRunner.manager.save(Exam, newExam)
            let randomQuestions: any = []
            await Promise.all(
                newCategories.map(async (category) => {
                    let checkCategoryDB = await this.categoryRepository.findOne({ where: { id: category.category_id } })
                    if (!checkCategoryDB) {
                        throw new Error("Category id: " + category.category_id + " not found")
                    }
                    let getExams = await this.find({
                        where: {
                            category_exams: {
                                category: {
                                    id: category.category_id,
                                }
                            },
                            type: ExamType.import
                        },
                        select: ["id"]
                    })
                    let examIds = getExams.map((exam: any) => exam.id)
                    let getRandomQuestion = await this.examQuestionRepository
                        .createQueryBuilder("e")
                        .where("e.exam_id IN (:...exam_ids)", { exam_ids: examIds })
                        .orderBy('RAND()')
                        .take(category.take)
                        .getMany()

                    await queryRunner.manager.save(CategoryExam, {
                        category: checkCategoryDB,
                        exam: examDB,
                        total: getRandomQuestion.length
                    })
                    randomQuestions.push(...getRandomQuestion)
                })
            )
            let dataInsert: any = []
            randomQuestions = randomQuestions.map((q: any) => {
                dataInsert.push({ question_id: q.question_id, exam_id: examDB.id })
                return q.question
            })
            await queryRunner.manager.insert(ExamQuestion, dataInsert)
            await queryRunner.commitTransaction()
            return {
                error: null, data: { exam: examDB, message: "Done!" }
            }
        } catch (error) {
            await queryRunner.rollbackTransaction();
            return { error: error, data: null }
        } finally {
            await queryRunner.release()
        }

    }

    async handleUploadExcel(file: Express.Multer.File, body: UploadExamDto, user: PayloadTokenInterface): Promise<ResponseServiceInterface<any>> {
        const queryRunner = this.dataSource.createQueryRunner();
        await queryRunner.connect();
        await queryRunner.startTransaction();
        try {
            if (!file.path) {
                throw new Error("Upload failed");
            }
            let { category_id, lang_type, exam_id } = body
            let category = await this.categoryRepository.findOne({ where: { id: category_id } })
            if (!category) {
                return { error: MessageError.ERROR_NOT_FOUND + 'category', data: null }
            }

            const workbook = new ExcelJS.Workbook();
            await workbook.xlsx.readFile(file.path);
            let promises = []

            if (exam_id != undefined) {
                let exam = await this.findOne({ where: { id: exam_id } })
                if (!exam) {
                    return { error: MessageError.ERROR_NOT_FOUND + 'exam', data: null }
                }
                let worksheet = workbook.getWorksheet(1);
                worksheet.eachRow({ includeEmpty: false }, async (row, rowNumber) => {
                    if (rowNumber == 1) return
                    promises.push(this.handleInsertQuestionAndAnswer(queryRunner, exam, row, rowNumber))
                });
            } else {
                let sheets = Array.from({ length: workbook.worksheets.length }, (_: any, i: number) => workbook.getWorksheet(i + 1))
                await Promise.all(
                    sheets.map(async (worksheet: ExcelJS.Worksheet, index: number) => {
                        let slugText = Helper.removeAccents(worksheet.name, true)
                        let checkSlug = await this.slugRepository.count({ where: { slug: slugText } })
                        let slugDB = await queryRunner.manager.save(Slug, {
                            slug: checkSlug != 0 ? slugText + "d" : slugText,
                            type: SlugType.exam,
                        })
                        let newExam: Partial<Exam> = {
                            title: worksheet.name,
                            // category,
                            lang_type,
                            slug: slugDB,
                            type: ExamType.user,
                            user_id: user.id
                        }
                        let examDB = await queryRunner.manager.save(Exam, newExam)
                        await queryRunner.manager.save(CategoryExam, {
                            category: category,
                            exam: examDB,
                            total: worksheet.rowCount
                        })
                        worksheet.eachRow({ includeEmpty: false }, async (row, rowNumber) => {
                            if (rowNumber == 1) return
                            promises.push(this.handleInsertQuestionAndAnswer(queryRunner, examDB, row, rowNumber))
                        });
                    })
                )

            }
            await Promise.all(promises)
            await queryRunner.commitTransaction();
            return { error: null, data: {} }
        } catch (error) {
            await queryRunner.rollbackTransaction();
            return { error: error, data: null }
        } finally {
            fs.unlinkSync(file.path)
            await queryRunner.release()
        }

    }

    async handleInsertQuestionAndAnswer(queryRunner: QueryRunner, exam: Exam, rows: ExcelJS.Row, rowNumber?: number): Promise<void> {
        if (rowNumber == 1) return
        let [_, questionIsr, aIsr, bIsr, cIsr, dIsr, answerIsr, recommendIsr]: any = rows.values
        let answersObj = {
            'a': aIsr,
            'b': bIsr,
            'c': cIsr,
            'd': dIsr,
        }
        let correctAnswer = answerIsr.trim().toLowerCase()
        let questionDb = await queryRunner.manager.save(Question, {
            title: questionIsr,
            recommend: recommendIsr
        })
        let answersDb = await Promise.all(
            Object.keys(answersObj).map(async (key) => {
                return queryRunner.manager.save(Answer, {
                    title: answersObj[key],
                    correct: answersObj[correctAnswer] && key == correctAnswer ? true : false,
                    question: questionDb
                })
            })
        )
        let checkAllTrue = answersDb.every((anw: Answer) => anw.correct)
        let checkAllFalse = answersDb.every((anw: Answer) => !anw.correct)
        if (checkAllTrue || checkAllFalse) {
            throw new Error(`Can detect correct answer for question: ` + questionDb.title)
        }
        await queryRunner.manager.save(ExamQuestion, {
            exam,
            question: questionDb
        })
    }

    async createExam(data: CreateExamDto, user: PayloadTokenInterface): Promise<ResponseServiceInterface<Partial<Exam>>> {
        let { title, category_id, time_end, time_start, total_generate_question, lang_type } = data
        let category = await this.categoryRepository.findOne({ where: { id: category_id } })
        if (!category) {
            return { error: MessageError.ERROR_NOT_FOUND + 'category', data: null }
        }
        let withTime = true
        let slug = Helper.removeAccents(title, withTime)
        let checkSlug = await this.slugRepository.count({ where: { slug } })
        if (!!checkSlug) {
            return { error: MessageError.ERROR_EXISTS, data: null }
        }
        let newSlug = await this.slugRepository.save(Object.assign(new Slug(), { slug, type: SlugType.exam }))
        let dataCreate: Partial<Exam> = {
            title,
            // category,
            slug: newSlug,
            // total_generate_question,
            lang_type,
            user_id: user.id
        }
        if (time_end && time_start) {
            dataCreate.time_start = time_start
            dataCreate.time_end = time_end
        }
        let newExam = await this.save(dataCreate)
        await this.categoryExamRepository.save({
            category: category,
            exam: newExam
        })
        return {
            error: null,
            data: newExam
        }
    }

    async updateExam(id: number, data: UpdateExamDto): Promise<ResponseServiceInterface<Partial<Exam>>> {
        let { title, category_ids, time_end, time_start, total_generate_question, lang_type } = data
        let exam = await this.findOne({ where: { id }, relations: { category_exams: true } })
        let exam_update: Partial<Exam> = {}
        if (!exam) {
            return { error: MessageError.ERROR_NOT_FOUND, data: null }
        }
        if (category_ids?.length) {
            let remove_exam_category_ids = exam.category_exams.filter((category_exam) => {
                if (!category_ids.includes(category_exam.category_id)) {
                    return category_exam
                }
            }).map(i => i.id)

            await Promise.all(
                category_ids.map(async (category_id: number) => {
                    let category = await this.categoryRepository.findOne({ where: { id: category_id } })
                    if (!category) {
                        throw new Error(MessageError.ERROR_NOT_FOUND + 'category')
                    }
                    let find = exam.category_exams.find((item) => item.category_id == category_id)
                    if (find) return
                    await this.categoryExamRepository.save({
                        category: category,
                        exam: exam
                    })
                })
            )
            this.categoryExamRepository.delete({ id: In(remove_exam_category_ids) })
        }
        if (title) {
            let slug_update = Helper.removeAccents(title, false)
            let slug_db = Helper.removeAccents(exam.title, false)
            if (slug_update != slug_db) {
                slug_update += "-" + Date.now()
                let checkSlug = await this.slugRepository.count({ where: { slug: slug_update } })
                if (!!checkSlug) {
                    return { error: MessageError.ERROR_EXISTS, data: null }
                }
                exam_update.slug = await this.slugRepository.save({ id: exam.slug_id, slug: slug_update })
                exam_update.title = title
            }
        }
        if (time_end && time_start) {
            exam_update.time_start = time_start
            exam_update.time_end = time_end
        }
        exam_update.lang_type = lang_type
        // exam_update.total_generate_question = total_generate_question
        let update = await this.updateOne({ id: exam.id }, exam_update, { relations: ["slug", "category_exams"] })
        return {
            error: null,
            data: update
        }
    }

    async getListExam(filter: BaseListFilterDto<any, any>): Promise<ResponseServiceInterface<any>> {
        let { limit = 10, page = 1 } = filter
        let query = this.repository
            .createQueryBuilder("e")
            .leftJoin("e.slug", "s")
            .addSelect(["s.id", "s.slug", "s.type"])
            .leftJoin("e.category_exams", "ce")
            .loadRelationCountAndMap("e.total_question", "e.exam_questions")

        this.handleFilter(query, filter, page, limit)
        let [list, total] = await query.getManyAndCount()
        return {
            error: null,
            data: {
                list,
                total,
                page,
                limit,
            }
        }
    }

    handleFilter(query: SelectQueryBuilder<Exam>, payload: BaseListFilterDto<FilterDto, any>, page: number, limit: number): any {
        if (payload.search) {
            let search = Helper.removeAccents(payload.search, false)
            query.andWhere("s.slug LIKE :search", { search: `%${search}%` })
        }
        if (payload?.filter?.type) {
            query.andWhere("e.type = :type", { type: payload.filter.type })
        }
        if (payload?.filter?.category_ids) {
            query.andWhere("ce.category_id IN (:...category_ids)", { category_ids: payload?.filter?.category_ids })
        }
        if (payload?.filter?.lang_type) {
            query.andWhere("e.lang_type = :lang_type", { lang_type: payload?.filter?.lang_type })
        }
        if (Object.keys(payload?.sort || {}).length > 0) {
            Object.keys(payload?.sort).forEach(key => {
                query.addOrderBy(`e.${key}`, payload?.sort[key]);
            })
        } else {
            query.orderBy("e.created_at", "DESC")
        }
        query.take(limit)
        query.skip((page - 1) * limit)
        return query
    }

    async startExam(slug: string, user: PayloadTokenInterface, query: any): Promise<ResponseServiceInterface<any>> {
        let { page = 1, limit = 60 } = query
        let exam = await this.findOne({ where: { slug: { slug } } })
        if (!exam || exam?.hidden) {
            return { error: MessageError.ERROR_NOT_FOUND, data: null }
        }
        let timeCurrent = new Date()
        let timeCurrentMili = timeCurrent.getTime()
        if (exam.time_end && exam.time_end < timeCurrent) {
            return { error: MessageError.ERROR_EXPIRES_EXAM, data: null }
        }
        if (exam.time_start && exam.time_start > timeCurrent) {
            return { error: MessageError.ERROR_EXPIRES_EXAM, data: null }
        }

        let historyBuildQuery = this.examHistoryRepository
            .createQueryBuilder("ex")
            .innerJoinAndSelect("ex.history_answers", "ha")
            .where("ex.exam_id = :exam_id", { exam_id: exam.id })
            .andWhere("ex.user_id = :user_id", { user_id: user.id })
            .orderBy("ex.created_at", "DESC")

        let buildQuery = this.examQuestionRepository
            .createQueryBuilder("eq")
            .leftJoin("eq.question", "q")
            .addSelect(["q.id", "q.title", "q.type"])
            .leftJoin("q.answers", "a")
            .addSelect(["a.id", "a.title"])
            .where("eq.exam_id = :exam_id", { exam_id: exam.id })

        let latestHistory = await historyBuildQuery.getOne()
        // Điều kiện chưa có lịch sử or lịch sử làm bài kết thúc thi thì tạo mới lịch sử 
        // TH1: Nếu thời gian làm bài được set. Tính thời gian làm bài mới nhất + số phút làm so với time hiện tại quá hay chưa? 
        let timeCondition = (exam.time_work_minutes && (latestHistory?.start_time.getTime() + exam.time_work_minutes * 60 * 1000 < timeCurrentMili));
        let condition = !latestHistory
            || (latestHistory && latestHistory.end_time)
            || timeCondition;

        condition && (buildQuery = buildQuery.orderBy('RAND()'))
        let questionsRandom = await buildQuery.getMany()

        let countWork = await this.examHistoryRepository.count({ where: { exam_id: exam.id, user_id: user.id } })
        if (countWork >= exam.total_work && (timeCondition || !exam.time_work_minutes)) {
            return { error: MessageError.ERROR_EXPIRES_EXAM, data: null }
        }

        if (condition) {
            console.log("create new history")
            let newHistory: Partial<ExamHistory> = {
                start_time: timeCurrent,
                user: user as User,
                exam: exam
            }
            let history = await this.examHistoryRepository.save(newHistory)
            let historyAnswers = questionsRandom.map(record => {
                return {
                    question: record.question,
                    exam_history: history
                }
            })
            await this.historyAnswerRepository.insert(historyAnswers)
            latestHistory = await historyBuildQuery.getOne()
        }

        let logQuestionIds = latestHistory.history_answers.sort((a, b) => a.id - b.id).map((i) => {
            return {
                id: i.question_id,
                answer_id: i.answer_id,
            }
        })
        let newQuestionsRandom: any[] = []
        newQuestionsRandom = logQuestionIds.map((q) => {
            let find = questionsRandom.find((question) => question.question_id === q.id)
            find.question.answers.sort((a, b) => a.id - b.id)
            find.question.answers = find.question.answers.map((item) => {
                return {
                    ...item,
                    user_choose: +(q.answer_id) == item.id ? true : false
                }
            })
            return { ...find.question, answer_id: q.answer_id }
        })
        let bodyEnd = newQuestionsRandom.map(i => {
            return {
                question_id: i.id,
                answer_id: i.answers[2].id
            }
        })
        return {
            error: null,
            data: {
                exam,
                // list: newQuestionsRandom.splice((page - 1) * limit, limit),
                bodyEnd
            }
        }
    }

    async endExam(slug: string, user: PayloadTokenInterface, body: ExamEndDto): Promise<ResponseServiceInterface<any>> {
        let { form } = body
        let exam = await this.findOne({ where: { slug: { slug } } })
        if (!exam) {
            return { error: MessageError.ERROR_NOT_FOUND, data: null }
        }
        let timeCurrent = new Date()
        let timeCurrentMili = timeCurrent.getTime()
        if (exam.time_end && exam.time_end < timeCurrent) {
            return { error: MessageError.ERROR_EXPIRES_EXAM, data: null }
        }
        if (exam.time_start && exam.time_start > timeCurrent) {
            return { error: MessageError.ERROR_EXPIRES_EXAM, data: null }
        }

        let questionsExam = await this.examQuestionRepository.find({
            where: { exam_id: exam.id },
            relations: {
                question: { answers: true }
            }
        })

        let historyExam = await this.examHistoryRepository.findOne({
            where: { exam_id: exam.id, user_id: user.id },
            order: { created_at: "DESC" }
        })

        if (historyExam.end_time) {
            return { error: MessageError.ERROR_EXPIRES_EXAM, data: null }
        }

        let totalQuestionCorrect = 0
        let questionScore = exam.score / questionsExam.length
        await Promise.all(
            questionsExam.map(async (row) => {
                let submitElement = form.find(q => q.question_id == row.question_id);
                let correctRow = row.question.answers.find(a => a.id == submitElement?.answer_id)
                if (submitElement) {
                    correctRow?.correct && totalQuestionCorrect++
                    await this.historyAnswerRepository.update({
                        question_id: row.question_id,
                        exam_history_id: historyExam.id
                    }, {
                        score: questionScore,
                        correct: (correctRow != undefined) && correctRow.correct,
                        answer_id: String(submitElement.answer_id)
                    })
                }
            })
        )

        historyExam.end_time = new Date()
        historyExam.score = questionScore * totalQuestionCorrect
        historyExam.total_correct_answer = totalQuestionCorrect
        await this.examHistoryRepository.save(historyExam)
        return { error: null, data: { historyExam } }
    }

    async updateLog(exam_id: number, body: UpdateLogExamDto, user: PayloadTokenInterface): Promise<ResponseServiceInterface<any>> {
        let { question_id, answer_id } = body
        let examHistory = await this.examHistoryRepository.findOne({
            where: {
                user_id: user.id,
                exam_id: exam_id,
            }, order: { created_at: "DESC" }
        })
        if (!examHistory || examHistory.end_time) {
            return { error: MessageError.ERROR_NOT_FOUND, data: null }
        }
        await this.historyAnswerRepository.update({
            question_id,
            exam_history_id: examHistory.id,
        }, {
            answer_id: String(answer_id)
        }
        )
        return { error: null, data: { message: "Done!" } }
    }

    async getExam(slug: string): Promise<ResponseServiceInterface<any>> {
        // let { page = 1, limit = 10 } = query
        let exam = await this.findOne({ where: { slug: { slug } } })
        if (!exam || exam.hidden) {
            return { error: MessageError.ERROR_NOT_FOUND, data: null }
        }
        let medias = await this.mediaRepository.find({ where: { ref_id: exam.id, ref_type: MediaType.exam } })
        // let [histories, total] = await this.examHistoryRepository.findAndCount({
        //     where: {
        //         user_id: user.id,
        //         exam_id: exam.id
        //     },
        //     order: { created_at: "DESC" },
        //     take: limit,
        //     skip: (page - 1) * limit
        // })

        return { error: null, data: { exam, medias } }
    }

    async getExamForAdmin(exam_id: number, query: any): Promise<ResponseServiceInterface<any>> {
        let { page = 1, limit = 10 } = Helper.transformQueryList(query)
        let exam = await this.findOne({ where: { id: exam_id } })
        if (!exam || exam.hidden) {
            return { error: MessageError.ERROR_NOT_FOUND, data: null }
        }
        let medias = await this.mediaRepository.find({ where: { ref_id: exam.id, ref_type: MediaType.exam } })
        let buildQuery = this.examQuestionRepository
            .createQueryBuilder("eq")
            .leftJoin("eq.question", "q")
            .addSelect(["q.id", "q.title", "q.type"])
            .leftJoin("q.answers", "a")
            .addSelect(["a.id", "a.title", "a.correct"])
            .where("eq.exam_id = :exam_id", { exam_id: exam.id })
            .skip((page - 1) * limit)
            .take(limit)
        let [questions, total] = await buildQuery.getManyAndCount()
        return { error: null, data: { exam, questions, page, total, limit, medias } }
    }

    async handleSlug(): Promise<ResponseServiceInterface<any>> {
        return
    }

    async usersInExam(slug: string, body: BaseListFilterDto<any, any>): Promise<ResponseServiceInterface<any>> {
        let { page = 1, limit = 20, sort } = body
        let exam = await this.findOne({ where: { slug: { slug } } })
        if (!exam) {
            return { error: MessageError.ERROR_NOT_FOUND, data: null }
        }
        let [histories, total] = await this.examHistoryRepository.findAndCount({
            where: {
                exam_id: exam.id
            },
            order: sort || { created_at: "DESC" },
            take: limit,
            skip: (page - 1) * limit
        })
        histories = histories.map(item => {
            return {
                ...item,
                total_minute_work: Helper.calculateTimeWorkExam(item.start_time, item.end_time)
            }
        })
        return { error: null, data: { list: histories, total, page, limit } }
    }

}   
